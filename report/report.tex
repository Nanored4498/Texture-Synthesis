\documentclass[12pt]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}
\usepackage[left=2.5cm,right=2.5cm,top=3cm,bottom=2.65cm]{geometry}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\title{
	Computational Geometry and Digital Images\\
	\textbf{Texture Synthesis}\\
	Rapport
}
\author{
	Yoann Coudert-\,-Osmont
	\and
	Jérémy Petithomme
}

\begin{document}
	
\maketitle

\section{Introduction}
	
La synthèse de texture consiste à créer une grande image à partir d'une petite image exemple ou à partir d'un modèle. La texture produite doit respecter une certaine structure mais si elle est produite à partir d'un exemple elle ne doit pas être une simple copie de l'exemple. Nous avons décidé de réaliser un génération de textures à partir d'exemples. \\
Les critères intéressant d'une génération de textures, sont la rapidité d'exécution, la qualité de l'image produite et le contrôle de l'utilisateur. Nous avons décidé d'implémenter un algorithme qui remplie très bien ce dernier critère de contrôlabilité. Nous nous sommes alors penché sur le reproduction du générateur de texture de Lefebvre et Hoppe \cite{Lef++} qui est basé sur la correspondance de voisinages. Ce générateur est parallélisé et peux donc être utilisé en temps réel sur les GPU actuels. Notre implémentation est faite en C++ et est exécuté sur CPU. Les performances sont alors moindres mais le résultat reste satisfaisant.

\subsection{Comment utiliser notre code}

\paragraph{Dépendances}
Certaines installations ont besoin d'être faites :
\begin{itemize}
	\item OpenMp pour la parallélisation. Pour l'installer : \verb|sudo apt install libomp-dev|.
	\item Une partie de la librairie C++ boost pour gérer les fichiers indépendamment du système. Pour l'installer : \verb|sudo apt install libboost-filesystem-dev|.
	\item La librairie C++ GTKmm est utilisée dans notre interface graphique. Pour l'installer : \verb|sudo apt install libgtkmm-3.0-dev|.
\end{itemize}

\paragraph{Le dossier \texttt{ims}}
Dans ce dossier se trouve 3 images et un dossier par images. Les dossiers contiennent des images dites de cohérences qui seront expliqués plus loin. Ces dossiers peuvent aussi contenir des images \verb|res.png| qui sont les résultats obtenus. Pour obtenir plus d'images d'exemples, vous pouvez vous placer dans le dossier \verb|ims| et lancer le script \verb|get_more_images.sh| qui téléchargera d'autres images avec leurs dossiers de cohérences.

\paragraph{Compiler et exécuter}
Nous avons deux exécutables. Le premier peut être créé via la commande \verb|make|. L'exécutable créé a alors le nom \verb|main| et permet d'exécuter notre générateur sur une image et de créer une image pour chaque étape de l'algorithme. Pour l'utiliser, tapez :
\begin{center}
	\texttt{./main <filename> [-c] [-t]}
\end{center}
Le premier argument est obligatoire et est le chemin d'accès à l'image d'exemple (par exemple \verb|ims/1.png|). Les deux paramètres suivants sont optionnels. \verb|-c| permet de calculer les images de cohérences si elle n'existent pas déjà. Si vous voulez les recalculer il faudra supprimer les images de cohérences actuelles. Les images de cohérences sont générés dans un dossier du même nom que l'image d'exemple. L'option \verb|-t| permet de rendre toroïdale l'image donnée en exemple. \\
Le second exécutable est celui de l'interface graphique. Pour créé cet exécutable il faut utiliser \verb|make g|. Pour lancer alors l'interface graphique il suffit de taper :
\begin{center}
	\verb|./gui [filename]|
\end{center}
Le paramètre \verb|filename| est cette fois-ci optionnelle puisque le fichier peut être chargé dans l'interface graphique. Une fenêtre s'ouvrira et vous aurez à gauche l'image générée et à droite plusieurs sliders permettant de contrôler la texture générée.

\section{Explication de l'algorithme}

\paragraph{Supposition carré}
Pour commencer on suppose que l'on part d'une image d'exemple $E$ qui est carrée. Si notre image est rectangulaire alors il suffit de prendre un carré de taille maximale de l'image de départ.

\paragraph{Astuce pour les images trop grandes}
Si l'image d'exemple est trop grande on divise sa largeur par $2^p$ avec $p$ choisi de manière à obtenir une nouvelle image de largeur comprise entre 129 et 256. Nous avons commencé par réduire la taille en faisant un filtrage gaussien puis en prenant le premier pixel de chaque bloc de largeur $2^p$ mais le résultat n'était pas au rendez vous. Nous sommes revenu sur quelque chose de plus simple en prenant la valeur moyenne sur chaque bloc de largeur $2^p$. On note $E_l$ l'image réduite et $E_h$ l'image de départ.

Une fois que notre algorithme a produit la map $S_l$ pointant vers les pixels de $E_l$, on construit une nouvelle image $I$ de meilleure qualité en faisant une interpolation. Voici la calcul effectué pour trouvé la nouvelle couleur du pixel à la position $(x, y)$.

%\begin{figure}
	\begin{algorithmic}[1]
		\Function{Magnify}{$x, y$}
			\State $x_L, \, y_L \gets x / 2^p, \, y / 2^p$
			\State $dp = (dp_x, dp_y) \gets x \mod 2^p, \, y \mod 2^p$
			\For{$i, j \in \{ 0, 1 \}^2$}
				\State $u_{i, j} \gets 2^p \left( S \left[ x_L + i, \, y_L + j \right] - \left( i, \, j \right) \right) + dp$
				\State $color \left[ i, \, j \right] \gets E_h \left[ u_{i, j} \right]$
			\EndFor
			\State \Return $color \left[ 0, \, 0 \right] (1 - dp_x) (1 - dp_y)
						+ color \left[ 1, \, 0 \right] dp_x (1 - dp_y)$
			\State $\qquad \qquad + \, color \left[ 0, \, 1 \right] (1 - dp_x) dp_y
						+ color \left[ 1, \, 1 \right] dp_x dp_y$
		\EndFunction
	\end{algorithmic}
%\end{figure}

\paragraph{A cité}
\cite{Ary++}

\appendix

\bibliographystyle{plain}
\bibliography{bib.bib}


\end{document}